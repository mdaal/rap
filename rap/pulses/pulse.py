# super-directory imports
from ..metadata import metadata
from ..env_var import env_var
from ..sweeps.sweep import sweep
# current directory imports
from .trace import trace
# data_management imports
from .data_management.load_legacy_pulse_gui_data import load_legacy_pulse_gui_data
from .data_management.load_JPL_pulse_data import load_JPL_pulse_data
from .data_management.utils import _define_pulse_array
# fitting imports
from .fitting.fit_sweeps import fit_sweeps, rotate_I_and_Q
# energy_resolution imports
from .energy_resolution.wavelength_calibration import (calculate_amplitudes, energy_fit,
                                                       binned_energy_fit, amplitude_fit)
from .energy_resolution.data_cuts import (characterize_data, plot_metrics, cut_peak_time,
                                          cut_prepulse_mean, cut_prepulse_rms,
                                          cut_postpulse_min_slope)
# filters imports
from .filters.template import Template
from .filters.filter import Filter
# pulse_array imports
from .pulse_array.pick_legacy_pulse_gui_channel import pick_legacy_pulse_gui_channel
from .pulse_array.pick_JPL_channel import pick_JPL_channel
# visualization imports
from .visualization.plot_IQ_trace import plot_IQ_trace
from .visualization.plot_wavelength_calibration import (plot_binned_energy_fit,
                                                        plot_energy_fit,
                                                        plot_amplitude_fit)

# external imports
import numpy as np
from astropy.constants import h, c
import warnings
import lmfit as lm


class pulse:
    """This class accesses pulse data and analyses energy resolution"""
    def __init__(self, **kword):
        """
        keywords can be:
        database_location = 'path/to/data.h5'
        """
        self.metadata = metadata()
        self.env_var = env_var(**kword)
        self.sweep = sweep()
        self.trace = trace()
        self.template = None
        self.filter = None

    def update_pulse_array(self, index, **kwargs):
        """
        Updates the Pulse_Array attribute with the keys and values in kwargs
        """
        _define_pulse_array(self.Pulse_Array, index, **kwargs)

    def pick_legacy_pulse_gui_channel(self, index):
        """
        Use this function to pick the channel to manipulate data from the Pulse_Array.
        Index is channel number to be selected.
        """
        pick_legacy_pulse_gui_channel(self.metadata, self.trace, self.sweep,
                                      self.Pulse_Array, index)

    def pick_JPL_channel(self):
        """
        Use this function to reload data from the Pulse_Array for JPL data
        """
        # only one channel so pick that
        pick_JPL_channel(self.metadata, self.trace, self.sweep, self.Pulse_Array)

    def load_legacy_pulse_gui_data(self, gui_data_path, energies=None, wavelengths=None,
                                   use_pulse_gui_psd=True):
        """
        Import data generated by Matlab pulse_gui progam into rap data structures, e.g.
        Pulse_Array, metadata, pulse() objects.

        gui_data_path is the directory containing the pulse_gui program generated data.
        This function finds the latest pulse_config_xxxxx.mat file in directory, then
        reads it to determine pulse data settings.
        The cooresponding pulse_data_xxxxx.dat file with the I and Q trace data is also
        read in.

        The energies and wavelengths kwargs are lists of the energies in eV and
        associated wavelengths of photons incedent on the resonator. Only specify one.

        use_pulse_gui_psd is a True/False value indicating whether to pull the power
        spectrum from the sweep gui data or the pulse gui data
        """
        if energies is None and wavelengths is None:
            raise ValueError('Specify one of the energies or wavelengths keyword '
                             'arguements')
        if energies is None:
            energies = (h.to('eV s').value * c.to('nm/s').value /
                        np.array(wavelengths, dtype=np.float64))

        del self.metadata
        self.metadata = metadata()

        self.pulse_data_columns_list, self.pulse_data_columns, self.Pulse_Array = \
            load_legacy_pulse_gui_data(self.metadata, gui_data_path, energies, self.sweep,
                                       use_pulse_gui_psd=use_pulse_gui_psd)

    def load_JPL_pulse_data(self, sweep_file, noise_file, pulse_file, energies=None,
                            wavelengths=None):
        """
        Import data generated by Nick Z's custom code for taking data at JPL.
        """
        if energies is None and wavelengths is None:
            raise ValueError('Specify one of the energies or wavelengths keyword '
                             'arguements')
        if energies is None:
            energies = (h.to('eV s').value * c.to('nm/s').value /
                        np.array(wavelengths, dtype=np.float64))

        del self.metadata
        self.metadata = metadata()

        self.pulse_data_columns_list, self.pulse_data_columns, self.Pulse_Array = \
            load_JPL_pulse_data(self.metadata, self.sweep, energies, sweep_file,
                                noise_file, pulse_file)

        # only one channel so pick it
        self.pick_JPL_channel()

    def fit_sweeps(self, Fit_Method="circle_and_phase", Show_Plot=False, Verbose=False):
        """
        Fit the pulse.sweep object using the specified Fit_Method.

        Show_Plot shows plots of the sweep fit.
        """
        fit_sweeps(self, Show_Plot=Show_Plot, Fit_Method=Fit_Method, Verbose=Verbose)

    def rotate_I_and_Q(self, Show_Plot=False):
        """
        Rotate the I, Q signals and noise traces by centering the sweep loop and
        rotating. Phase and amplitude signals and noise traces are also created.

        Show_Plot shows plots of the IQ data traces.
        """
        rotate_I_and_Q(self.trace)

        if Show_Plot:
            plot_IQ_trace(self.trace)

    def make_template(self, Show_Plot=False, Verbose=False):
        """
        Make a template from the trace data
        """
        self.template = Template(self.trace)
        self.template.make_template(Show_Plot=Show_Plot)

        if Verbose:
            print(self.template.result.fit_report())

    def make_filter(self):
        """
        Make a filter from the trace data and template
        """
        if self.template is None:
            raise ValueError('make the template before making the filter')
        self.filter = Filter(self.template)
        self.filter.make_filter()

    def calculate_amplitudes(self):
        """
        Calculate pulse amplitudes using the trace data and filter.
        """
        self.trace.amplitudes = calculate_amplitudes(self.trace, self.filter)

    def amplitude_fit(self, n_bins=100, fit_type='gaussian', calibration='linear',
                      Show_Plot=False, Verbose=False, plot_guess=True,
                      **parameter_kwargs):
        """
        Fit the pulse amplitudes to a collection of distributions and find a rough
        calibration.
        """
        self.trace.amplitude_fit_result, cal = \
            amplitude_fit(self.trace.amplitudes, self.trace.energies, n_bins=n_bins,
                          fit_type=fit_type, calibration=calibration, **parameter_kwargs)
        # set the calibration and type
        if self.trace.amplitude_fit_result.success:
            self.trace.calibration = cal
            self.trace.calibration_type = calibration
        if Verbose:
            # ignore bug in lmfit print function
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", RuntimeWarning)
                print(self.trace.amplitude_fit_result.fit_report())
        if Show_Plot:
            plot_amplitude_fit(self.trace.amplitude_fit_result, self.trace.amplitudes,
                               n_bins, plot_guess=plot_guess)

    def binned_energy_fit(self, n_bins=100, fit_type='gaussian',
                          Show_Plot=False, Verbose=False, calibration='linear',
                          plot_guess=True, **parameter_kwargs):
        """
        Simultaneously fit a calibration (between amplitude and energy) and the pulse
        amplitudes to distributions in energy space. This function bins the data and is
        more stable than the standard energy fitting routine. However, the binning and
        the assumption of modified gaussian errors makes this routine less statistically
        robust.
        """
        if (self.trace.calibration is not None and
           self.trace.calibration_type == calibration):
            if Verbose:
                print('using precomputed calibration as starting guess')
            parameter_kwargs.update({'d0_a': {'value': self.trace.calibration[0]},
                                     'd0_b': {'value': self.trace.calibration[1]},
                                     'd0_c': {'value': self.trace.calibration[2]}})
        self.trace.binned_fit_result, cal = \
            binned_energy_fit(self.trace.amplitudes, self.trace.energies, n_bins=n_bins,
                              fit_type=fit_type, calibration=calibration,
                              **parameter_kwargs)
        # set the calibration and type
        if self.trace.binned_fit_result.success:
            self.trace.calibration = cal
            self.trace.calibration_type = calibration
        if Verbose:
            # ignore bug in lmfit print function
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", RuntimeWarning)
                print(self.trace.binned_fit_result.fit_report())
        if Show_Plot:
            plot_binned_energy_fit(self.trace.binned_fit_result, self.trace.amplitudes,
                                   n_bins, self.trace.calibration, plot_guess=plot_guess)

    def energy_fit(self, fit_type='gaussian', Show_Plot=False, Verbose=False,
                   calibration='linear', plot_guess=True, n_plot_bins=100,
                   **parameter_kwargs):
        """
        Simultaneously fit a calibration (between amplitude and energy) and the pulse
        amplitudes to distributions in energy space. This function gives the maximum
        likelihood estimate for the distribution and calibration parameters under the
        assumption that the data was generated from the model.
        """
        if (self.trace.calibration is not None and
           self.trace.calibration_type == calibration):
            if Verbose:
                print('using precomputed calibration as starting guess')
            parameter_kwargs.update({'d0_a': {'value': self.trace.calibration[0]},
                                     'd0_b': {'value': self.trace.calibration[1]},
                                     'd0_c': {'value': self.trace.calibration[2]}})
        result, cal, model, params = \
            energy_fit(self.trace.amplitudes, self.trace.energies, fit_type=fit_type,
                       calibration=calibration, **parameter_kwargs)
        self.trace.energy_fit_result = result
        self.trace.energy_fit_model = model
        self.trace.energy_fit_init = params
        # set the calibration and type
        if self.trace.energy_fit_result.success:
            self.trace.calibration = cal
            self.trace.calibration_type = calibration
        if Verbose:
            # ignore bug in lmfit print function
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", RuntimeWarning)
                print(lm.fit_report(self.trace.energy_fit_result))
        if Show_Plot:
            plot_energy_fit(self.trace.energy_fit_result, self.trace.amplitudes,
                            n_plot_bins, model, params, plot_guess=plot_guess)

    def characterize_data(self, Show_Plot=False):
        """
        Calculate metrics to use for data cuts
        """
        characterize_data(self.trace, self.filter)
        if Show_Plot:
            plot_metrics(self.trace)

    def cut_peak_time(self, minimum, maximum):
        """
        Cut on the pulse peak time. Useful for pulse pileup or bad triggers.
        """
        cut_peak_time(self.trace, minimum, maximum)

    def cut_prepulse_mean(self, minimum, maximum):
        """
        Cut on the prepulse mean. Useful for prepulse contamination.
        """
        cut_prepulse_mean(self.trace, minimum, maximum)

    def cut_prepulse_rms(self, minimum, maximum):
        """
        Cut on the prepulse rms. Useful for prepulse contamination.
        """
        cut_prepulse_rms(self.trace, minimum, maximum)

    def cut_postpulse_min_slope(self, minimum):
        """
        Cut on the post pulse minimum slope. Useful for post pulse contamination.
        """
        cut_postpulse_min_slope(self.trace, minimum)
